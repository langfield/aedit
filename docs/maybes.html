<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ki.maybes API documentation</title>
<meta name="description" content="Factory functions for safely handling errors in type construction." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="ki/maybes.html">
<link rel="icon" href="u1F367-shavedice.svg">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ki.maybes</code></h1>
</header>
<section id="section-intro">
<p>Factory functions for safely handling errors in type construction.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34;Factory functions for safely handling errors in type construction.&#34;&#34;&#34;

# pylint: disable=invalid-name, missing-class-docstring, broad-except
# pylint: disable=too-many-return-statements, too-many-lines, import-self
# pylint: disable=no-value-for-parameter

import re
import traceback
import configparser
from pathlib import Path

import git
from lark import Lark
from beartype import beartype
from beartype.typing import Union, Dict, Any, List, Tuple, Iterable

import anki
from anki.decks import DeckTreeNode
from anki.errors import NotFoundError
from anki.collection import Collection

import ki.maybes as M
import ki.functional as F
from ki.types import (
    MODELS_FILE,
    File,
    Dir,
    EmptyDir,
    NoPath,
    NoFile,
    Link,
    PseudoFile,
    KiRepo,
    KiRev,
    Rev,
    Template,
    Field,
    ColNote,
    Deck,
    Root,
    DotKi,
    PlannedLink,
    Notetype,
    Submodule,
    NotetypeKeyError,
    UnnamedNotetypeError,
    MissingFieldOrdinalError,
    MissingNoteIdError,
    NoteFieldKeyError,
    MissingFileError,
    MissingDirectoryError,
    ExpectedFileButGotDirectoryError,
    ExpectedDirectoryButGotFileError,
    ExpectedEmptyDirectoryButGotNonEmptyDirectoryError,
    ExpectedNonexistentPathError,
    StrangeExtantPathError,
    NotKiRepoError,
    GitRefNotFoundError,
    GitHeadRefNotFoundError,
    GitFileModeParseError,
    AnkiAlreadyOpenError,
)
from ki.transformer import NoteTransformer

curried = F.curried

KI = &#34;.ki&#34;
GIT = F.GIT
MEDIA = &#34;_media&#34;
GITIGNORE_FILE = &#34;.gitignore&#34;
GITMODULES_FILE = F.GITMODULES_FILE

CONFIG_FILE = &#34;config&#34;
HASHES_FILE = &#34;hashes&#34;
BACKUPS_DIR = &#34;backups&#34;

REMOTE_CONFIG_SECTION = &#34;remote&#34;
COLLECTION_FILE_PATH_CONFIG_FIELD = &#34;path&#34;


BACKUPS_DIR_INFO = &#34;&#34;&#34;
This is the &#39;.ki/backups&#39; directory, used to store backups of the &#39;.anki2&#39;
collection database file before ki overwrites it during a push. It may be
missing because the current ki repository has become corrupted.
&#34;&#34;&#34;

CONFIG_FILE_INFO = &#34;&#34;&#34;
This is the &#39;.ki/config&#39; file, used to store the path to a &#39;.anki2&#39; collection
database file. It may be missing because the current ki repository has become
corrupted.
&#34;&#34;&#34;

HASHES_FILE_INFO = &#34;&#34;&#34;
This is the &#39;.ki/hashes&#39; file, used to store recent md5sums of the &#39;.anki2&#39;
collection database file, which allow ki to determine when updates should be
rejected, i.e. when the user must pull remote changes before they can push
local ones. It may be missing because the current ki repository has become
corrupted.
&#34;&#34;&#34;

MODELS_FILE_INFO = f&#34;&#34;&#34;
This is the top-level &#39;{MODELS_FILE}&#39; file, which contains serialized notetypes
for all notes in the current repository. Ki should always create this during
cloning. If it has been manually deleted, try reverting to an earlier commit.
Otherwise, it may indicate that the repository has become corrupted.
&#34;&#34;&#34;

COL_FILE_INFO = &#34;&#34;&#34;
This is the &#39;.anki2&#39; database file that contains all the data for a user&#39;s
collection. This path was contained in the &#39;.ki/config&#39; file, indicating that
the collection this repository previously referred to has been moved or
deleted. The path can be manually fixed by editing the &#39;.ki/config&#39; file.
&#34;&#34;&#34;


# MAYBES


@beartype
def nopath(path: Path) -&gt; NoPath:
    &#34;&#34;&#34;
    Maybe convert a path to a NoPath, i.e. a path that did not exist at
    resolve-time, which is when this function was called.
    &#34;&#34;&#34;
    path = path.resolve()
    if path.exists():
        raise ExpectedNonexistentPathError(path)
    return NoPath(path)


@beartype
def nofile(path: Path) -&gt; NoFile:
    &#34;&#34;&#34;
    Maybe convert a path to a NoPath, i.e. a path that did not exist at
    resolve-time, which is when this function was called.
    &#34;&#34;&#34;
    path = path.resolve()
    path = M.nopath(path)
    M.xdir(path.parent)
    return NoFile(path)


@beartype
def xfile(path: Path, info: str = &#34;&#34;) -&gt; File:
    &#34;&#34;&#34;
    Attempt to instantiate a File.
    &#34;&#34;&#34;
    # Resolve path.
    path = path.resolve()

    # Check that path exists and is a file.
    if not path.exists():
        raise MissingFileError(path, info)
    if path.is_dir():
        raise ExpectedFileButGotDirectoryError(path, info)
    if not path.is_file():
        raise StrangeExtantPathError(path, info)

    # Must be an extant file.
    return File(path)


@beartype
def xdir(path: Path, info: str = &#34;&#34;) -&gt; Dir:
    &#34;&#34;&#34;
    Attempt to instantiate a Dir.
    &#34;&#34;&#34;
    # Resolve path.
    path = path.resolve()

    # Check that path exists and is a directory.
    if not path.exists():
        raise MissingDirectoryError(path, info)
    if path.is_dir():
        return Dir(path)
    if path.is_file():
        raise ExpectedDirectoryButGotFileError(path, info)
    raise StrangeExtantPathError(path, info)


@beartype
def emptydir(path: Path) -&gt; Dir:
    &#34;&#34;&#34;
    Attempt to instantiate an empty Dir.
    &#34;&#34;&#34;
    # Check if it&#39;s an extant directory.
    directory: Dir = M.xdir(path)
    if F.is_empty(directory):
        return EmptyDir(Path(directory).resolve())
    raise ExpectedEmptyDirectoryButGotNonEmptyDirectoryError(directory)


@beartype
def repo(root: Dir) -&gt; git.Repo:
    &#34;&#34;&#34;Read a git repo safely.&#34;&#34;&#34;
    try:
        repository = git.Repo(root)
    except git.InvalidGitRepositoryError as err:
        # TODO: Make this error more descriptive. It currently sucks. A test
        # should be written for &#39;M.kirepo()&#39; in which we return this error.
        raise err
    return repository


@beartype
def kirepo(cwd: Dir) -&gt; KiRepo:
    &#34;&#34;&#34;Get the containing ki repository of `path`.&#34;&#34;&#34;
    current = cwd

    while not F.is_root(current):
        kid = F.chk(current / KI)
        if isinstance(kid, Dir):
            break
        current = F.parent(current)

    if F.is_root(current):
        raise NotKiRepoError()

    # Root directory and ki directory of repo now guaranteed to exist.
    root = current
    repository: git.Repo = M.repo(root)

    # Check that relevant files in .ki/ subdirectory exist.
    backups_dir = M.xdir(kid / BACKUPS_DIR, info=BACKUPS_DIR_INFO)
    config_file = M.xfile(kid / CONFIG_FILE, info=CONFIG_FILE_INFO)
    hashes_file = M.xfile(kid / HASHES_FILE, info=HASHES_FILE_INFO)
    models_file = M.xfile(root / MODELS_FILE, info=MODELS_FILE_INFO)

    # Check that collection file exists.
    config = configparser.ConfigParser()
    config.read(config_file)
    col_file = Path(config[REMOTE_CONFIG_SECTION][COLLECTION_FILE_PATH_CONFIG_FIELD])
    col_file = M.xfile(col_file, info=COL_FILE_INFO)

    return KiRepo(
        repository,
        root,
        kid,
        col_file,
        backups_dir,
        config_file,
        hashes_file,
        models_file,
    )


@beartype
def rev(repository: git.Repo, sha: str) -&gt; Rev:
    &#34;&#34;&#34;Validate a commit SHA against a repository and return a `Rev`.&#34;&#34;&#34;
    if not F.rev_exists(repository, sha):
        raise GitRefNotFoundError(repository, sha)
    return Rev(repository, sha)


@beartype
def head(repository: git.Repo) -&gt; Rev:
    &#34;&#34;&#34;Return a `Rev` for HEAD of current branch.&#34;&#34;&#34;
    # GitPython raises a ValueError when references don&#39;t exist.
    try:
        r = Rev(repository, repository.head.commit.hexsha)
    except ValueError as err:
        raise GitHeadRefNotFoundError(repository, err) from err
    return r


@beartype
def head_ki(kirepository: KiRepo) -&gt; KiRev:
    &#34;&#34;&#34;Return a `KiRev` for HEAD of current branch.&#34;&#34;&#34;
    # GitPython raises a ValueError when references don&#39;t exist.
    try:
        r = KiRev(kirepository, kirepository.repo.head.commit.hexsha)
    except ValueError as err:
        raise GitHeadRefNotFoundError(kirepository.repo, err) from err
    return r


@beartype
def collection(col_file: File) -&gt; Collection:
    &#34;&#34;&#34;Open a collection or raise a pretty exception.&#34;&#34;&#34;
    # We hold cwd constant (otherwise Anki changes it).
    cwd: Dir = F.cwd()
    try:
        col = Collection(col_file)
    except anki.errors.DBError as err:
        raise AnkiAlreadyOpenError(str(err)) from err
    finally:
        F.chdir(cwd)
    return col


@beartype
def hardlink(l: Link) -&gt; File:
    &#34;&#34;&#34;Replace a symlink with its target.&#34;&#34;&#34;
    # Treat true POSIX symlink case.
    tgt = F.chk(l.resolve())
    return F.copyfile(tgt, l)


@beartype
def filemode(file: Union[File, Dir, PseudoFile, Link]) -&gt; int:
    &#34;&#34;&#34;Get git file mode.&#34;&#34;&#34;
    try:
        # We must search from file upwards in case inside submodule.
        root_repo = git.Repo(file, search_parent_directories=True)
        out = root_repo.git.ls_files([&#34;-s&#34;, str(file)])

        # Treat case where file is untracked.
        if out == &#34;&#34;:
            return -1

        mode: int = int(out.split()[0])
    except Exception as err:
        raise GitFileModeParseError(file, out) from err
    return mode


@beartype
def template(t: Dict[str, Any]) -&gt; Template:
    &#34;&#34;&#34;Construct a template.&#34;&#34;&#34;
    # pylint: disable=redefined-builtin
    name, qfmt, afmt, ord = t[&#34;name&#34;], t[&#34;qfmt&#34;], t[&#34;afmt&#34;], t[&#34;ord&#34;]
    return Template(name=name, qfmt=qfmt, afmt=afmt, ord=ord)


@beartype
def field(fld: Dict[str, Any]) -&gt; Field:
    &#34;&#34;&#34;Construct a field.&#34;&#34;&#34;
    return Field(name=fld[&#34;name&#34;], ord=fld[&#34;ord&#34;])


@beartype
def notetype(nt: Dict[str, Any]) -&gt; Notetype:
    &#34;&#34;&#34;
    Convert an Anki NotetypeDict into a Notetype dataclass.

    Anki returns objects of type `NotetypeDict` (see pylib/anki/models.py)
    when you call a method like `col.models.all()`. This is a dictionary
    mapping strings to various stuff, and we read all its data into a python
    dataclass here so that we can access it safely. Since we don&#39;t expect Anki
    to ever give us &#39;invalid&#39; notetypes (since we define &#39;valid&#39; as being
    processable by Anki), we return an exception if the parse fails.

    Note on naming convention: Below, abbreviated variable names represent
    dicts coming from Anki, like `nt: NotetypeDict` or `fld: FieldDict`.
    Full words like `field: Field` represent ki dataclasses. The parameters
    of the dataclasses, however, use abbreviations for consistency with Anki
    map keys.
    &#34;&#34;&#34;
    # If we can&#39;t even read the name of the notetype, then we can&#39;t print out a
    # nice error message in the event of a `KeyError`. So we have to print out
    # a different error message saying that the notetype doesn&#39;t have a name
    # field.
    try:
        nt[&#34;name&#34;]
    except KeyError as err:
        raise UnnamedNotetypeError(nt) from err
    try:
        fields: Dict[int, Field] = {fld[&#34;ord&#34;]: M.field(fld) for fld in nt[&#34;flds&#34;]}
        if nt[&#34;sortf&#34;] not in fields:
            raise MissingFieldOrdinalError(ord=nt[&#34;sortf&#34;], model=nt[&#34;name&#34;])
        return Notetype(
            id=nt[&#34;id&#34;],
            name=nt[&#34;name&#34;],
            type=nt[&#34;type&#34;],
            flds=list(fields.values()),
            tmpls=list(map(M.template, nt[&#34;tmpls&#34;])),
            sortf=fields[nt[&#34;sortf&#34;]],
            dict=nt,
        )
    except KeyError as err:
        raise NotetypeKeyError(key=str(err), name=str(nt[&#34;name&#34;])) from err


@beartype
def colnote(col: Collection, nid: int) -&gt; ColNote:
    &#34;&#34;&#34;Get a dataclass representation of an Anki note.&#34;&#34;&#34;
    try:
        note = col.get_note(nid)
    except NotFoundError as err:
        raise MissingNoteIdError(nid) from err
    nt: Notetype = M.notetype(note.note_type())

    # Get sort field content. See comment where we subscript in the same way in
    # `push_note()`.
    try:
        sfld: str = note[nt.sortf.name]
    except KeyError as err:
        raise NoteFieldKeyError(str(err), nid) from err

    # TODO: Remove implicit assumption that all cards are in the same deck, and
    # work with cards instead of notes.
    try:
        deck = col.decks.name(note.cards()[0].did)
    except IndexError as err:
        F.red(f&#34;{note.cards() = }&#34;)
        F.red(f&#34;{note.guid = }&#34;)
        F.red(f&#34;{note.id = }&#34;)
        raise err
    return ColNote(
        n=note,
        new=False,
        deck=deck,
        title=&#34;&#34;,
        markdown=False,
        notetype=nt,
        sfld=sfld,
    )


@beartype
def deckd(deck_name: str, targetdir: Dir) -&gt; Dir:
    &#34;&#34;&#34;
    Construct path to deck directory and create it, allowing the case in which
    the directory already exists because we already created one of its
    children, in which case this function is a no-op.
    &#34;&#34;&#34;
    # Strip leading periods so we don&#39;t get hidden folders.
    components = deck_name.split(&#34;::&#34;)
    components = [re.sub(r&#34;^\.&#34;, r&#34;&#34;, comp) for comp in components]
    components = [re.sub(r&#34;/&#34;, r&#34;-&#34;, comp) for comp in components]
    deck_path = Path(targetdir, *components)
    return F.force_mkdir(deck_path)


@curried
@beartype
def tree(col: Collection, targetd: Dir, root: DeckTreeNode) -&gt; Union[Root, Deck]:
    &#34;&#34;&#34;Get the deck directory and did for a decknode.&#34;&#34;&#34;
    did = root.deck_id
    name = col.decks.name(did)
    children: List[Deck] = list(map(M.tree(col, targetd), root.children))
    if root.deck_id == 0:
        deckdir, mediadir = None, None
        return Root(
            did=did,
            node=root,
            deckd=None,
            mediad=None,
            fullname=name,
            children=children,
        )
    deckdir = M.deckd(name, targetd)
    mediadir: Dir = F.force_mkdir(deckdir / MEDIA)
    return Deck(
        did=did,
        node=root,
        deckd=deckdir,
        mediad=mediadir,
        fullname=name,
        children=children,
    )


@curried
@beartype
def link(targetd: Dir, l: PlannedLink) -&gt; None:
    &#34;&#34;&#34;Create the symlink `l`.&#34;&#34;&#34;
    distance = len(l.link.parent.relative_to(targetd).parts)
    target: Path = Path(&#34;../&#34; * distance) / l.tgt.relative_to(targetd)
    try:
        F.symlink(l.link, target)
    except OSError as _:
        trace = traceback.format_exc(limit=3)
        F.yellow(f&#34;Failed to create symlink &#39;{l.link}&#39; -&gt; &#39;{target}&#39;\n{trace}&#34;)


@beartype
def empty_kirepo(root: EmptyDir) -&gt; Tuple[EmptyDir, EmptyDir]:
    &#34;&#34;&#34;Initialize subdirs for a ki repo.&#34;&#34;&#34;
    kidir = F.mksubdir(root, Path(KI))
    mediadir = F.mksubdir(EmptyDir(root), Path(MEDIA))
    return kidir, mediadir


@beartype
def dotki(kidir: EmptyDir) -&gt; DotKi:
    &#34;&#34;&#34;Create empty metadata files in `.ki/`.&#34;&#34;&#34;
    config = F.touch(kidir, CONFIG_FILE)
    backups = F.mksubdir(kidir, Path(BACKUPS_DIR))
    return DotKi(config=config, backups=backups)


@curried
@beartype
def submodule(parent_repo: git.Repo, sm: git.Submodule) -&gt; Submodule:
    &#34;&#34;&#34;
    Construct a map that sends submodule relative roots, that is, the relative
    path of a submodule root directory to the top-level root directory of the
    ki repository, to `git.Repo` objects for each submodule.
    &#34;&#34;&#34;
    sm_repo: git.Repo = sm.module()
    sm_root: Dir = F.root(sm_repo)
    sm_rel_root: Path = sm_root.relative_to(F.root(parent_repo))
    try:
        branch = sm_repo.active_branch.name
    except TypeError:
        h: git.Head = next(iter(sm_repo.branches))
        branch = h.name
    return Submodule(sm=sm, sm_repo=sm_repo, rel_root=sm_rel_root, branch=branch)


@beartype
def submodules(r: git.Repo) -&gt; Dict[Path, Submodule]:
    &#34;&#34;&#34;Map submodule relative roots to `Submodule`s.&#34;&#34;&#34;
    sms: Iterable[git.Submodule] = r.submodules
    sms = filter(lambda sm: sm.exists() and sm.module_exists(), sms)
    subs: Iterable[Submodule] = map(M.submodule(r), sms)
    return {s.rel_root: s for s in subs}


@beartype
def gitcopy(r: git.Repo, remote_root: Dir, unsub: bool) -&gt; git.Repo:
    &#34;&#34;&#34;Replace all files in `r` with contents of `remote_root`.&#34;&#34;&#34;
    git_copy = F.copytree(F.gitd(r), F.chk(F.mkdtemp() / &#34;GIT&#34;))
    r.close()
    root: NoFile = F.rmtree(F.root(r))
    del r
    root: Dir = F.copytree(remote_root, root)

    r: git.Repo = M.repo(root)
    if unsub:
        r = F.unsubmodule(r)
    gitd: NoPath = F.rmtree(F.gitd(r))
    del r
    F.copytree(git_copy, F.chk(gitd))

    # Note that we do not commit, so changes are in working tree.
    r: git.Repo = M.repo(root)
    return r


@beartype
def parser_and_transformer() -&gt; Tuple[Lark, NoteTransformer]:
    &#34;&#34;&#34;Read grammar.&#34;&#34;&#34;
    # TODO: Should we assume this always exists? A nice error message should be
    # printed on initialization if the grammar file is missing. No computation
    # should be done, and none of the click commands should work.
    grammar_path = Path(__file__).resolve().parent / &#34;grammar.lark&#34;
    grammar = grammar_path.read_text(encoding=&#34;UTF-8&#34;)

    # Instantiate parser.
    parser = Lark(grammar, start=&#34;note&#34;, parser=&#34;lalr&#34;)
    transformer = NoteTransformer()
    return parser, transformer</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ki.maybes.collection"><code class="name flex">
<span>def <span class="ident">collection</span></span>(<span>col_file: <a title="ki.types.File" href="types.html#ki.types.File">File</a>) ‑> anki.collection.Collection</span>
</code></dt>
<dd>
<div class="desc"><p>Open a collection or raise a pretty exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def collection(col_file: File) -&gt; Collection:
    &#34;&#34;&#34;Open a collection or raise a pretty exception.&#34;&#34;&#34;
    # We hold cwd constant (otherwise Anki changes it).
    cwd: Dir = F.cwd()
    try:
        col = Collection(col_file)
    except anki.errors.DBError as err:
        raise AnkiAlreadyOpenError(str(err)) from err
    finally:
        F.chdir(cwd)
    return col</code></pre>
</details>
</dd>
<dt id="ki.maybes.colnote"><code class="name flex">
<span>def <span class="ident">colnote</span></span>(<span>col: anki.collection.Collection, nid: int) ‑> <a title="ki.types.ColNote" href="types.html#ki.types.ColNote">ColNote</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get a dataclass representation of an Anki note.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def colnote(col: Collection, nid: int) -&gt; ColNote:
    &#34;&#34;&#34;Get a dataclass representation of an Anki note.&#34;&#34;&#34;
    try:
        note = col.get_note(nid)
    except NotFoundError as err:
        raise MissingNoteIdError(nid) from err
    nt: Notetype = M.notetype(note.note_type())

    # Get sort field content. See comment where we subscript in the same way in
    # `push_note()`.
    try:
        sfld: str = note[nt.sortf.name]
    except KeyError as err:
        raise NoteFieldKeyError(str(err), nid) from err

    # TODO: Remove implicit assumption that all cards are in the same deck, and
    # work with cards instead of notes.
    try:
        deck = col.decks.name(note.cards()[0].did)
    except IndexError as err:
        F.red(f&#34;{note.cards() = }&#34;)
        F.red(f&#34;{note.guid = }&#34;)
        F.red(f&#34;{note.id = }&#34;)
        raise err
    return ColNote(
        n=note,
        new=False,
        deck=deck,
        title=&#34;&#34;,
        markdown=False,
        notetype=nt,
        sfld=sfld,
    )</code></pre>
</details>
</dd>
<dt id="ki.maybes.deckd"><code class="name flex">
<span>def <span class="ident">deckd</span></span>(<span>deck_name: str, targetdir: <a title="ki.types.Dir" href="types.html#ki.types.Dir">Dir</a>) ‑> <a title="ki.types.Dir" href="types.html#ki.types.Dir">Dir</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct path to deck directory and create it, allowing the case in which
the directory already exists because we already created one of its
children, in which case this function is a no-op.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def deckd(deck_name: str, targetdir: Dir) -&gt; Dir:
    &#34;&#34;&#34;
    Construct path to deck directory and create it, allowing the case in which
    the directory already exists because we already created one of its
    children, in which case this function is a no-op.
    &#34;&#34;&#34;
    # Strip leading periods so we don&#39;t get hidden folders.
    components = deck_name.split(&#34;::&#34;)
    components = [re.sub(r&#34;^\.&#34;, r&#34;&#34;, comp) for comp in components]
    components = [re.sub(r&#34;/&#34;, r&#34;-&#34;, comp) for comp in components]
    deck_path = Path(targetdir, *components)
    return F.force_mkdir(deck_path)</code></pre>
</details>
</dd>
<dt id="ki.maybes.dotki"><code class="name flex">
<span>def <span class="ident">dotki</span></span>(<span>kidir: <a title="ki.types.EmptyDir" href="types.html#ki.types.EmptyDir">EmptyDir</a>) ‑> <a title="ki.types.DotKi" href="types.html#ki.types.DotKi">DotKi</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create empty metadata files in <code>.ki/</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def dotki(kidir: EmptyDir) -&gt; DotKi:
    &#34;&#34;&#34;Create empty metadata files in `.ki/`.&#34;&#34;&#34;
    config = F.touch(kidir, CONFIG_FILE)
    backups = F.mksubdir(kidir, Path(BACKUPS_DIR))
    return DotKi(config=config, backups=backups)</code></pre>
</details>
</dd>
<dt id="ki.maybes.empty_kirepo"><code class="name flex">
<span>def <span class="ident">empty_kirepo</span></span>(<span>root: <a title="ki.types.EmptyDir" href="types.html#ki.types.EmptyDir">EmptyDir</a>) ‑> tuple[<a title="ki.types.EmptyDir" href="types.html#ki.types.EmptyDir">EmptyDir</a>, <a title="ki.types.EmptyDir" href="types.html#ki.types.EmptyDir">EmptyDir</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize subdirs for a ki repo.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def empty_kirepo(root: EmptyDir) -&gt; Tuple[EmptyDir, EmptyDir]:
    &#34;&#34;&#34;Initialize subdirs for a ki repo.&#34;&#34;&#34;
    kidir = F.mksubdir(root, Path(KI))
    mediadir = F.mksubdir(EmptyDir(root), Path(MEDIA))
    return kidir, mediadir</code></pre>
</details>
</dd>
<dt id="ki.maybes.emptydir"><code class="name flex">
<span>def <span class="ident">emptydir</span></span>(<span>path: pathlib.Path) ‑> <a title="ki.types.Dir" href="types.html#ki.types.Dir">Dir</a></span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to instantiate an empty Dir.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def emptydir(path: Path) -&gt; Dir:
    &#34;&#34;&#34;
    Attempt to instantiate an empty Dir.
    &#34;&#34;&#34;
    # Check if it&#39;s an extant directory.
    directory: Dir = M.xdir(path)
    if F.is_empty(directory):
        return EmptyDir(Path(directory).resolve())
    raise ExpectedEmptyDirectoryButGotNonEmptyDirectoryError(directory)</code></pre>
</details>
</dd>
<dt id="ki.maybes.field"><code class="name flex">
<span>def <span class="ident">field</span></span>(<span>fld: dict[str, typing.Any]) ‑> <a title="ki.types.Field" href="types.html#ki.types.Field">Field</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct a field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def field(fld: Dict[str, Any]) -&gt; Field:
    &#34;&#34;&#34;Construct a field.&#34;&#34;&#34;
    return Field(name=fld[&#34;name&#34;], ord=fld[&#34;ord&#34;])</code></pre>
</details>
</dd>
<dt id="ki.maybes.filemode"><code class="name flex">
<span>def <span class="ident">filemode</span></span>(<span>file: Union[<a title="ki.types.File" href="types.html#ki.types.File">File</a>, <a title="ki.types.Dir" href="types.html#ki.types.Dir">Dir</a>, <a title="ki.types.PseudoFile" href="types.html#ki.types.PseudoFile">PseudoFile</a>, <a title="ki.types.Link" href="types.html#ki.types.Link">Link</a>]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Get git file mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def filemode(file: Union[File, Dir, PseudoFile, Link]) -&gt; int:
    &#34;&#34;&#34;Get git file mode.&#34;&#34;&#34;
    try:
        # We must search from file upwards in case inside submodule.
        root_repo = git.Repo(file, search_parent_directories=True)
        out = root_repo.git.ls_files([&#34;-s&#34;, str(file)])

        # Treat case where file is untracked.
        if out == &#34;&#34;:
            return -1

        mode: int = int(out.split()[0])
    except Exception as err:
        raise GitFileModeParseError(file, out) from err
    return mode</code></pre>
</details>
</dd>
<dt id="ki.maybes.gitcopy"><code class="name flex">
<span>def <span class="ident">gitcopy</span></span>(<span>r: git.repo.base.Repo, remote_root: <a title="ki.types.Dir" href="types.html#ki.types.Dir">Dir</a>, unsub: bool) ‑> git.repo.base.Repo</span>
</code></dt>
<dd>
<div class="desc"><p>Replace all files in <code>r</code> with contents of <code>remote_root</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def gitcopy(r: git.Repo, remote_root: Dir, unsub: bool) -&gt; git.Repo:
    &#34;&#34;&#34;Replace all files in `r` with contents of `remote_root`.&#34;&#34;&#34;
    git_copy = F.copytree(F.gitd(r), F.chk(F.mkdtemp() / &#34;GIT&#34;))
    r.close()
    root: NoFile = F.rmtree(F.root(r))
    del r
    root: Dir = F.copytree(remote_root, root)

    r: git.Repo = M.repo(root)
    if unsub:
        r = F.unsubmodule(r)
    gitd: NoPath = F.rmtree(F.gitd(r))
    del r
    F.copytree(git_copy, F.chk(gitd))

    # Note that we do not commit, so changes are in working tree.
    r: git.Repo = M.repo(root)
    return r</code></pre>
</details>
</dd>
<dt id="ki.maybes.hardlink"><code class="name flex">
<span>def <span class="ident">hardlink</span></span>(<span>l: <a title="ki.types.Link" href="types.html#ki.types.Link">Link</a>) ‑> <a title="ki.types.File" href="types.html#ki.types.File">File</a></span>
</code></dt>
<dd>
<div class="desc"><p>Replace a symlink with its target.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def hardlink(l: Link) -&gt; File:
    &#34;&#34;&#34;Replace a symlink with its target.&#34;&#34;&#34;
    # Treat true POSIX symlink case.
    tgt = F.chk(l.resolve())
    return F.copyfile(tgt, l)</code></pre>
</details>
</dd>
<dt id="ki.maybes.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>repository: git.repo.base.Repo) ‑> <a title="ki.types.Rev" href="types.html#ki.types.Rev">Rev</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a <code>Rev</code> for HEAD of current branch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def head(repository: git.Repo) -&gt; Rev:
    &#34;&#34;&#34;Return a `Rev` for HEAD of current branch.&#34;&#34;&#34;
    # GitPython raises a ValueError when references don&#39;t exist.
    try:
        r = Rev(repository, repository.head.commit.hexsha)
    except ValueError as err:
        raise GitHeadRefNotFoundError(repository, err) from err
    return r</code></pre>
</details>
</dd>
<dt id="ki.maybes.head_ki"><code class="name flex">
<span>def <span class="ident">head_ki</span></span>(<span>kirepository: <a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a>) ‑> <a title="ki.types.KiRev" href="types.html#ki.types.KiRev">KiRev</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a <code>KiRev</code> for HEAD of current branch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def head_ki(kirepository: KiRepo) -&gt; KiRev:
    &#34;&#34;&#34;Return a `KiRev` for HEAD of current branch.&#34;&#34;&#34;
    # GitPython raises a ValueError when references don&#39;t exist.
    try:
        r = KiRev(kirepository, kirepository.repo.head.commit.hexsha)
    except ValueError as err:
        raise GitHeadRefNotFoundError(kirepository.repo, err) from err
    return r</code></pre>
</details>
</dd>
<dt id="ki.maybes.kirepo"><code class="name flex">
<span>def <span class="ident">kirepo</span></span>(<span>cwd: <a title="ki.types.Dir" href="types.html#ki.types.Dir">Dir</a>) ‑> <a title="ki.types.KiRepo" href="types.html#ki.types.KiRepo">KiRepo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get the containing ki repository of <code>path</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def kirepo(cwd: Dir) -&gt; KiRepo:
    &#34;&#34;&#34;Get the containing ki repository of `path`.&#34;&#34;&#34;
    current = cwd

    while not F.is_root(current):
        kid = F.chk(current / KI)
        if isinstance(kid, Dir):
            break
        current = F.parent(current)

    if F.is_root(current):
        raise NotKiRepoError()

    # Root directory and ki directory of repo now guaranteed to exist.
    root = current
    repository: git.Repo = M.repo(root)

    # Check that relevant files in .ki/ subdirectory exist.
    backups_dir = M.xdir(kid / BACKUPS_DIR, info=BACKUPS_DIR_INFO)
    config_file = M.xfile(kid / CONFIG_FILE, info=CONFIG_FILE_INFO)
    hashes_file = M.xfile(kid / HASHES_FILE, info=HASHES_FILE_INFO)
    models_file = M.xfile(root / MODELS_FILE, info=MODELS_FILE_INFO)

    # Check that collection file exists.
    config = configparser.ConfigParser()
    config.read(config_file)
    col_file = Path(config[REMOTE_CONFIG_SECTION][COLLECTION_FILE_PATH_CONFIG_FIELD])
    col_file = M.xfile(col_file, info=COL_FILE_INFO)

    return KiRepo(
        repository,
        root,
        kid,
        col_file,
        backups_dir,
        config_file,
        hashes_file,
        models_file,
    )</code></pre>
</details>
</dd>
<dt id="ki.maybes.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>targetd: <a title="ki.types.Dir" href="types.html#ki.types.Dir">Dir</a>, l: <a title="ki.types.PlannedLink" href="types.html#ki.types.PlannedLink">PlannedLink</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Create the symlink <code>l</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@curried
@beartype
def link(targetd: Dir, l: PlannedLink) -&gt; None:
    &#34;&#34;&#34;Create the symlink `l`.&#34;&#34;&#34;
    distance = len(l.link.parent.relative_to(targetd).parts)
    target: Path = Path(&#34;../&#34; * distance) / l.tgt.relative_to(targetd)
    try:
        F.symlink(l.link, target)
    except OSError as _:
        trace = traceback.format_exc(limit=3)
        F.yellow(f&#34;Failed to create symlink &#39;{l.link}&#39; -&gt; &#39;{target}&#39;\n{trace}&#34;)</code></pre>
</details>
</dd>
<dt id="ki.maybes.nofile"><code class="name flex">
<span>def <span class="ident">nofile</span></span>(<span>path: pathlib.Path) ‑> <a title="ki.types.NoFile" href="types.html#ki.types.NoFile">NoFile</a></span>
</code></dt>
<dd>
<div class="desc"><p>Maybe convert a path to a NoPath, i.e. a path that did not exist at
resolve-time, which is when this function was called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def nofile(path: Path) -&gt; NoFile:
    &#34;&#34;&#34;
    Maybe convert a path to a NoPath, i.e. a path that did not exist at
    resolve-time, which is when this function was called.
    &#34;&#34;&#34;
    path = path.resolve()
    path = M.nopath(path)
    M.xdir(path.parent)
    return NoFile(path)</code></pre>
</details>
</dd>
<dt id="ki.maybes.nopath"><code class="name flex">
<span>def <span class="ident">nopath</span></span>(<span>path: pathlib.Path) ‑> <a title="ki.types.NoPath" href="types.html#ki.types.NoPath">NoPath</a></span>
</code></dt>
<dd>
<div class="desc"><p>Maybe convert a path to a NoPath, i.e. a path that did not exist at
resolve-time, which is when this function was called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def nopath(path: Path) -&gt; NoPath:
    &#34;&#34;&#34;
    Maybe convert a path to a NoPath, i.e. a path that did not exist at
    resolve-time, which is when this function was called.
    &#34;&#34;&#34;
    path = path.resolve()
    if path.exists():
        raise ExpectedNonexistentPathError(path)
    return NoPath(path)</code></pre>
</details>
</dd>
<dt id="ki.maybes.notetype"><code class="name flex">
<span>def <span class="ident">notetype</span></span>(<span>nt: dict[str, typing.Any]) ‑> <a title="ki.types.Notetype" href="types.html#ki.types.Notetype">Notetype</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert an Anki NotetypeDict into a Notetype dataclass.</p>
<p>Anki returns objects of type <code>NotetypeDict</code> (see pylib/anki/models.py)
when you call a method like <code>col.models.all()</code>. This is a dictionary
mapping strings to various stuff, and we read all its data into a python
dataclass here so that we can access it safely. Since we don't expect Anki
to ever give us 'invalid' notetypes (since we define 'valid' as being
processable by Anki), we return an exception if the parse fails.</p>
<p>Note on naming convention: Below, abbreviated variable names represent
dicts coming from Anki, like <code>nt: NotetypeDict</code> or <code>fld: FieldDict</code>.
Full words like <code>field: Field</code> represent ki dataclasses. The parameters
of the dataclasses, however, use abbreviations for consistency with Anki
map keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def notetype(nt: Dict[str, Any]) -&gt; Notetype:
    &#34;&#34;&#34;
    Convert an Anki NotetypeDict into a Notetype dataclass.

    Anki returns objects of type `NotetypeDict` (see pylib/anki/models.py)
    when you call a method like `col.models.all()`. This is a dictionary
    mapping strings to various stuff, and we read all its data into a python
    dataclass here so that we can access it safely. Since we don&#39;t expect Anki
    to ever give us &#39;invalid&#39; notetypes (since we define &#39;valid&#39; as being
    processable by Anki), we return an exception if the parse fails.

    Note on naming convention: Below, abbreviated variable names represent
    dicts coming from Anki, like `nt: NotetypeDict` or `fld: FieldDict`.
    Full words like `field: Field` represent ki dataclasses. The parameters
    of the dataclasses, however, use abbreviations for consistency with Anki
    map keys.
    &#34;&#34;&#34;
    # If we can&#39;t even read the name of the notetype, then we can&#39;t print out a
    # nice error message in the event of a `KeyError`. So we have to print out
    # a different error message saying that the notetype doesn&#39;t have a name
    # field.
    try:
        nt[&#34;name&#34;]
    except KeyError as err:
        raise UnnamedNotetypeError(nt) from err
    try:
        fields: Dict[int, Field] = {fld[&#34;ord&#34;]: M.field(fld) for fld in nt[&#34;flds&#34;]}
        if nt[&#34;sortf&#34;] not in fields:
            raise MissingFieldOrdinalError(ord=nt[&#34;sortf&#34;], model=nt[&#34;name&#34;])
        return Notetype(
            id=nt[&#34;id&#34;],
            name=nt[&#34;name&#34;],
            type=nt[&#34;type&#34;],
            flds=list(fields.values()),
            tmpls=list(map(M.template, nt[&#34;tmpls&#34;])),
            sortf=fields[nt[&#34;sortf&#34;]],
            dict=nt,
        )
    except KeyError as err:
        raise NotetypeKeyError(key=str(err), name=str(nt[&#34;name&#34;])) from err</code></pre>
</details>
</dd>
<dt id="ki.maybes.parser_and_transformer"><code class="name flex">
<span>def <span class="ident">parser_and_transformer</span></span>(<span>) ‑> tuple[lark.lark.Lark, <a title="ki.transformer.NoteTransformer" href="transformer.html#ki.transformer.NoteTransformer">NoteTransformer</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Read grammar.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def parser_and_transformer() -&gt; Tuple[Lark, NoteTransformer]:
    &#34;&#34;&#34;Read grammar.&#34;&#34;&#34;
    # TODO: Should we assume this always exists? A nice error message should be
    # printed on initialization if the grammar file is missing. No computation
    # should be done, and none of the click commands should work.
    grammar_path = Path(__file__).resolve().parent / &#34;grammar.lark&#34;
    grammar = grammar_path.read_text(encoding=&#34;UTF-8&#34;)

    # Instantiate parser.
    parser = Lark(grammar, start=&#34;note&#34;, parser=&#34;lalr&#34;)
    transformer = NoteTransformer()
    return parser, transformer</code></pre>
</details>
</dd>
<dt id="ki.maybes.repo"><code class="name flex">
<span>def <span class="ident">repo</span></span>(<span>root: <a title="ki.types.Dir" href="types.html#ki.types.Dir">Dir</a>) ‑> git.repo.base.Repo</span>
</code></dt>
<dd>
<div class="desc"><p>Read a git repo safely.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def repo(root: Dir) -&gt; git.Repo:
    &#34;&#34;&#34;Read a git repo safely.&#34;&#34;&#34;
    try:
        repository = git.Repo(root)
    except git.InvalidGitRepositoryError as err:
        # TODO: Make this error more descriptive. It currently sucks. A test
        # should be written for &#39;M.kirepo()&#39; in which we return this error.
        raise err
    return repository</code></pre>
</details>
</dd>
<dt id="ki.maybes.rev"><code class="name flex">
<span>def <span class="ident">rev</span></span>(<span>repository: git.repo.base.Repo, sha: str) ‑> <a title="ki.types.Rev" href="types.html#ki.types.Rev">Rev</a></span>
</code></dt>
<dd>
<div class="desc"><p>Validate a commit SHA against a repository and return a <code>Rev</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def rev(repository: git.Repo, sha: str) -&gt; Rev:
    &#34;&#34;&#34;Validate a commit SHA against a repository and return a `Rev`.&#34;&#34;&#34;
    if not F.rev_exists(repository, sha):
        raise GitRefNotFoundError(repository, sha)
    return Rev(repository, sha)</code></pre>
</details>
</dd>
<dt id="ki.maybes.submodule"><code class="name flex">
<span>def <span class="ident">submodule</span></span>(<span>parent_repo: git.repo.base.Repo, sm: git.objects.submodule.base.Submodule) ‑> <a title="ki.types.Submodule" href="types.html#ki.types.Submodule">Submodule</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct a map that sends submodule relative roots, that is, the relative
path of a submodule root directory to the top-level root directory of the
ki repository, to <code>git.Repo</code> objects for each submodule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@curried
@beartype
def submodule(parent_repo: git.Repo, sm: git.Submodule) -&gt; Submodule:
    &#34;&#34;&#34;
    Construct a map that sends submodule relative roots, that is, the relative
    path of a submodule root directory to the top-level root directory of the
    ki repository, to `git.Repo` objects for each submodule.
    &#34;&#34;&#34;
    sm_repo: git.Repo = sm.module()
    sm_root: Dir = F.root(sm_repo)
    sm_rel_root: Path = sm_root.relative_to(F.root(parent_repo))
    try:
        branch = sm_repo.active_branch.name
    except TypeError:
        h: git.Head = next(iter(sm_repo.branches))
        branch = h.name
    return Submodule(sm=sm, sm_repo=sm_repo, rel_root=sm_rel_root, branch=branch)</code></pre>
</details>
</dd>
<dt id="ki.maybes.submodules"><code class="name flex">
<span>def <span class="ident">submodules</span></span>(<span>r: git.repo.base.Repo) ‑> dict[pathlib.Path, <a title="ki.types.Submodule" href="types.html#ki.types.Submodule">Submodule</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Map submodule relative roots to <code>Submodule</code>s.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def submodules(r: git.Repo) -&gt; Dict[Path, Submodule]:
    &#34;&#34;&#34;Map submodule relative roots to `Submodule`s.&#34;&#34;&#34;
    sms: Iterable[git.Submodule] = r.submodules
    sms = filter(lambda sm: sm.exists() and sm.module_exists(), sms)
    subs: Iterable[Submodule] = map(M.submodule(r), sms)
    return {s.rel_root: s for s in subs}</code></pre>
</details>
</dd>
<dt id="ki.maybes.template"><code class="name flex">
<span>def <span class="ident">template</span></span>(<span>t: dict[str, typing.Any]) ‑> <a title="ki.types.Template" href="types.html#ki.types.Template">Template</a></span>
</code></dt>
<dd>
<div class="desc"><p>Construct a template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def template(t: Dict[str, Any]) -&gt; Template:
    &#34;&#34;&#34;Construct a template.&#34;&#34;&#34;
    # pylint: disable=redefined-builtin
    name, qfmt, afmt, ord = t[&#34;name&#34;], t[&#34;qfmt&#34;], t[&#34;afmt&#34;], t[&#34;ord&#34;]
    return Template(name=name, qfmt=qfmt, afmt=afmt, ord=ord)</code></pre>
</details>
</dd>
<dt id="ki.maybes.tree"><code class="name flex">
<span>def <span class="ident">tree</span></span>(<span>col: anki.collection.Collection, targetd: <a title="ki.types.Dir" href="types.html#ki.types.Dir">Dir</a>, root: anki.decks_pb2.DeckTreeNode) ‑> Union[<a title="ki.types.Root" href="types.html#ki.types.Root">Root</a>, <a title="ki.types.Deck" href="types.html#ki.types.Deck">Deck</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the deck directory and did for a decknode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@curried
@beartype
def tree(col: Collection, targetd: Dir, root: DeckTreeNode) -&gt; Union[Root, Deck]:
    &#34;&#34;&#34;Get the deck directory and did for a decknode.&#34;&#34;&#34;
    did = root.deck_id
    name = col.decks.name(did)
    children: List[Deck] = list(map(M.tree(col, targetd), root.children))
    if root.deck_id == 0:
        deckdir, mediadir = None, None
        return Root(
            did=did,
            node=root,
            deckd=None,
            mediad=None,
            fullname=name,
            children=children,
        )
    deckdir = M.deckd(name, targetd)
    mediadir: Dir = F.force_mkdir(deckdir / MEDIA)
    return Deck(
        did=did,
        node=root,
        deckd=deckdir,
        mediad=mediadir,
        fullname=name,
        children=children,
    )</code></pre>
</details>
</dd>
<dt id="ki.maybes.xdir"><code class="name flex">
<span>def <span class="ident">xdir</span></span>(<span>path: pathlib.Path, info: str = '') ‑> <a title="ki.types.Dir" href="types.html#ki.types.Dir">Dir</a></span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to instantiate a Dir.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def xdir(path: Path, info: str = &#34;&#34;) -&gt; Dir:
    &#34;&#34;&#34;
    Attempt to instantiate a Dir.
    &#34;&#34;&#34;
    # Resolve path.
    path = path.resolve()

    # Check that path exists and is a directory.
    if not path.exists():
        raise MissingDirectoryError(path, info)
    if path.is_dir():
        return Dir(path)
    if path.is_file():
        raise ExpectedDirectoryButGotFileError(path, info)
    raise StrangeExtantPathError(path, info)</code></pre>
</details>
</dd>
<dt id="ki.maybes.xfile"><code class="name flex">
<span>def <span class="ident">xfile</span></span>(<span>path: pathlib.Path, info: str = '') ‑> <a title="ki.types.File" href="types.html#ki.types.File">File</a></span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to instantiate a File.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype
def xfile(path: Path, info: str = &#34;&#34;) -&gt; File:
    &#34;&#34;&#34;
    Attempt to instantiate a File.
    &#34;&#34;&#34;
    # Resolve path.
    path = path.resolve()

    # Check that path exists and is a file.
    if not path.exists():
        raise MissingFileError(path, info)
    if path.is_dir():
        raise ExpectedFileButGotDirectoryError(path, info)
    if not path.is_file():
        raise StrangeExtantPathError(path, info)

    # Must be an extant file.
    return File(path)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="ki Home" href="index.html">
<img src="u1F367-shavedice.svg" alt=""> ki
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ki" href="index.html">ki</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ki.maybes.collection" href="#ki.maybes.collection">collection</a></code></li>
<li><code><a title="ki.maybes.colnote" href="#ki.maybes.colnote">colnote</a></code></li>
<li><code><a title="ki.maybes.deckd" href="#ki.maybes.deckd">deckd</a></code></li>
<li><code><a title="ki.maybes.dotki" href="#ki.maybes.dotki">dotki</a></code></li>
<li><code><a title="ki.maybes.empty_kirepo" href="#ki.maybes.empty_kirepo">empty_kirepo</a></code></li>
<li><code><a title="ki.maybes.emptydir" href="#ki.maybes.emptydir">emptydir</a></code></li>
<li><code><a title="ki.maybes.field" href="#ki.maybes.field">field</a></code></li>
<li><code><a title="ki.maybes.filemode" href="#ki.maybes.filemode">filemode</a></code></li>
<li><code><a title="ki.maybes.gitcopy" href="#ki.maybes.gitcopy">gitcopy</a></code></li>
<li><code><a title="ki.maybes.hardlink" href="#ki.maybes.hardlink">hardlink</a></code></li>
<li><code><a title="ki.maybes.head" href="#ki.maybes.head">head</a></code></li>
<li><code><a title="ki.maybes.head_ki" href="#ki.maybes.head_ki">head_ki</a></code></li>
<li><code><a title="ki.maybes.kirepo" href="#ki.maybes.kirepo">kirepo</a></code></li>
<li><code><a title="ki.maybes.link" href="#ki.maybes.link">link</a></code></li>
<li><code><a title="ki.maybes.nofile" href="#ki.maybes.nofile">nofile</a></code></li>
<li><code><a title="ki.maybes.nopath" href="#ki.maybes.nopath">nopath</a></code></li>
<li><code><a title="ki.maybes.notetype" href="#ki.maybes.notetype">notetype</a></code></li>
<li><code><a title="ki.maybes.parser_and_transformer" href="#ki.maybes.parser_and_transformer">parser_and_transformer</a></code></li>
<li><code><a title="ki.maybes.repo" href="#ki.maybes.repo">repo</a></code></li>
<li><code><a title="ki.maybes.rev" href="#ki.maybes.rev">rev</a></code></li>
<li><code><a title="ki.maybes.submodule" href="#ki.maybes.submodule">submodule</a></code></li>
<li><code><a title="ki.maybes.submodules" href="#ki.maybes.submodules">submodules</a></code></li>
<li><code><a title="ki.maybes.template" href="#ki.maybes.template">template</a></code></li>
<li><code><a title="ki.maybes.tree" href="#ki.maybes.tree">tree</a></code></li>
<li><code><a title="ki.maybes.xdir" href="#ki.maybes.xdir">xdir</a></code></li>
<li><code><a title="ki.maybes.xfile" href="#ki.maybes.xfile">xfile</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>